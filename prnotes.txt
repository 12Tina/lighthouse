# New Audit: `legacy-javascript` 

Goal: Encourage developers to deliver modern code to modern browsers.

This audit fails if legacy code is found in any first party code. The recommended action is to use the [module/nomodule pattern](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/), in addition to [@babel/preset-modules](https://github.com/babel/preset-modules) (instead of @babel/preset-env).

## Legacy code, defined

Legacy code contain either polyfills or transformed code for features that browsers that support ES Modules don't need. The relevant polyfils / transforms are in this [spreadsheet](https://docs.google.com/spreadsheets/d/1z28Au8wo8-c2UsM2lDVEOJcI3jOkb2c951xEBqzBKCc/edit).

Polyfills overwrite native prototypes in regular patterns (`String.prototype.startsWith = ...`, `Object.defineProperty(String.prototype, 'startsWith', ...`) or via common libraries (core-js). The patterns that emerge are fairly detectable with a [regex](https://imgflip.com/tag/regex).

Only some transforms are detectable.

## Follow up work

1. Use third-party-web
1. Use source maps
1. Estimate savings to make an opprotunity

## Runtime cost

node lighthouse-core/scripts/compare-timings.js --name my-collection --collect -n 3 --lh-flags='--only-audits=legacy-javascript' --urls https://www.coursehero.com/sg https://www.wix.com https://www.wikipedia.org

node lighthouse-core/scripts/compare-timings.js --name my-collection --summarize --measure-filter 'legacy-javascript'


